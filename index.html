<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js webgl - loaders - MMD loader</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="main.css" />
    <style>
      body {
        background-color: #fff;
        color: #444;
      }

      a {
        color: #08f;
      }
    </style>
  </head>

  <body>
    <div id="info">
      <a href="https://threejs.org" target="_blank" rel="noopener">three.js</a>
      - MMDLoader test<br />
      <a
        href="https://github.com/mrdoob/three.js/tree/master/examples/models/mmd#readme"
        target="_blank"
        rel="noopener"
        >MMD Assets license</a
      ><br />
      Copyright
      <a
        href="https://sites.google.com/view/evpvp/"
        target="_blank"
        rel="noopener"
        >Model Data</a
      >
      <a
        href="http://seiga.nicovideo.jp/seiga/im5162984"
        target="_blank"
        rel="noopener"
        >Pose Data</a
      >
    </div>

    <script src="js/libs/ammo.wasm.js"></script>
    <script src="scoreoutputer.min.js"></script>
    <script>
      // 建構子 ScoreOutputer 接受一個字串，該字串為 csv 的檔案名稱
      // 以下面範例，檔名就為 "109598105(總分: 6).csv"
      var so = new ScoreOutputer("109598105");
      so.installCSS(function () {
        // 安裝 bootstrap 的 css，如果在 html 上方引用 bootstrap 5.1.1 的話就不用使用 installCSS ，注意一定要 bootstrap css 5.1.1 版
        // installCSS 接收一個 callback 當作參數，作為成功安裝 bootstrap css 的回呼函式

        //加入項目，分數，完成狀況
        //第一個參數為 項目名稱
        //第2個參數為 項目分數
        //第3個參數為 完成狀況，有完成 true/未完成 false
        //有幾個項目就呼叫幾個 addChild
        //addChild 要比 renderModal 先呼叫
        so.addChild("視角可以移動及放大", 2, true);
        so.addChild("回答問題", 2, true);
        so.addChild("在畫面上畫出左眼的邊框", 2, true);
        so.addChild("複製左眼邊框變化到右眼", 2, true);
        so.addChild("可選擇當前讀取角色或按鍵選擇上 / 下一隻角色", 1, false);
        so.addChild("可儲存座標點檔案", 1, false);

        //產生自評表，參數如下所示
        so.renderModal(
          //1. 自評表插入位置 (預設 document.body)
          document.body,
          //2. 自評表背景 (預設紅色)
          "rgba(100,45,58,1)",
          //3. 自評表文字顏色 (預設白色)
          "white",
          //4. 自評表文字大小 (預設 14pt)
          "15pt",
          //5. 自評表 checkbox 文字大小 (預設多少忘了)
          "15px",
          //6. 自評表標題 (預設 "自我評分表")
          (dialogTitle = "自我評分表")
        );

        //設定下載按鈕 <-- 一定要呼叫這個函數，不然沒有下載功能
        so.installDownloadBtn();

        //產生 "開啟自評表按鈕"
        so.renderBtn(
          //自評表按鈕插入位置
          document.querySelector("#info"),
          //自評表按鈕文字
          "開啟自評表"
        );
      });
    </script>
    <script type="module">
      import * as THREE from "./build/three.module.js";
      import { GUI } from "./jsm/libs/dat.gui.module.js";
      import { OrbitControls } from "./jsm/controls/OrbitControls.js";
      import { OutlineEffect } from "./jsm/effects/OutlineEffect.js";
      import { MMDLoader } from "./jsm/loaders/MMDLoader.js";
      import { MMDAnimationHelper } from "./jsm/animation/MMDAnimationHelper.js";

      let camera, scene, renderer, effect;
      let mesh, helper;
      let raycaster = new THREE.Raycaster();
      let mouse = new THREE.Vector2();
      let intersects;
      let lineMaterial1, lineMaterial2, lineMaterial3, lineMaterial4;
      let LDownLine, LLeftLine, LUpLine, LRightLine;

      let Point1 = [];
      let Point2 = [];
      let Point3 = [];
      let Point4 = [];

      let RPoint1 = [];
      let RPoint2 = [];
      let RPoint3 = [];
      let RPoint4 = [];

      let RDLine;
      let RULine;
      let RLLine;
      let RRLine;
      //按鍵開關
      let keyUP = false;
      let keyDOWN = false;
      let keyLEFT = false;
      let keyRIGHT = false;

      let targetList = [];
      const vpds = [];

      Ammo().then(function (AmmoLib) {
        Ammo = AmmoLib;

        init();
        animate();
      });

      function init() {
        const container = document.createElement("div");
        document.body.appendChild(container);
        let scale = 30;
        camera = new THREE.OrthographicCamera(
          window.innerWidth / scale / -2,
          window.innerWidth / scale / 2,
          window.innerHeight / scale / 2,
          window.innerHeight / scale / -2,
          0.1,
          1000
        );
        //camera = new THREE.PerspectiveCamera( 45, window.innerWidth / window.innerHeight, 1, 2000 );
        camera.position.z = 25;

        // scene

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);

        const ambient = new THREE.AmbientLight(0x666666);
        scene.add(ambient);

        const directionalLight = new THREE.DirectionalLight(0x887766);
        directionalLight.position.set(-1, 1, 1).normalize();
        scene.add(directionalLight);

        //線材質設定
        lineMaterial1 = new THREE.LineBasicMaterial({
          color: 0xe60000,
        });
        lineMaterial2 = new THREE.LineBasicMaterial({
          color: 0xffbf00,
        });
        lineMaterial3 = new THREE.LineBasicMaterial({
          color: 0x654321,
        });
        lineMaterial4 = new THREE.LineBasicMaterial({
          color: 0x800080,
        });

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        container.appendChild(renderer.domElement);

        effect = new OutlineEffect(renderer);

        // model

        function onProgress(xhr) {
          if (xhr.lengthComputable) {
            const percentComplete = (xhr.loaded / xhr.total) * 100;
            console.log(Math.round(percentComplete, 2) + "% downloaded");
          }
        }

        const modelFile = [
          "models/mmd/kizunaai/kizunaai.pmx",
          "models/mmd/るいのれ式物述有栖_配布用フォルダ/物述有栖.pmx",
        ];

        const vpdFiles = [
          "models/mmd/vpds/01.vpd",
          "models/mmd/vpds/02.vpd",
          "models/mmd/vpds/03.vpd",
          "models/mmd/vpds/04.vpd",
          "models/mmd/vpds/05.vpd",
          "models/mmd/vpds/06.vpd",
          "models/mmd/vpds/07.vpd",
          "models/mmd/vpds/08.vpd",
          //'models/mmd/vpds/09.vpd',
          //'models/mmd/vpds/10.vpd',
          "models/mmd/vpds/11.vpd",
        ];

        helper = new MMDAnimationHelper();

        const loader = new MMDLoader();

        loader.load(
          modelFile[0],
          function (object) {
            mesh = object;
            mesh.position.y = -10;

            scene.add(mesh);
            targetList.push(mesh);
            let vpdIndex = 0;

            function loadVpd() {
              const vpdFile = vpdFiles[vpdIndex];

              loader.loadVPD(
                vpdFile,
                false,
                function (vpd) {
                  vpds.push(vpd);

                  vpdIndex++;

                  if (vpdIndex < vpdFiles.length) {
                    loadVpd();
                  } else {
                    initGui();
                  }
                },
                onProgress,
                null
              );
            }

            loadVpd();
          },
          onProgress,
          null
        );

        window.addEventListener("resize", onWindowResize);
        //鏡頭控制
        const cameracontrols = new OrbitControls(camera, renderer.domElement);
        cameracontrols.minDistance = 10;
        cameracontrols.maxDistance = 100;
        cameracontrols.enableRotate = false;
        function initGui() {
          const gui = new GUI();

          const dictionary = mesh.morphTargetDictionary;

          const controls = {};
          const keys = [];

          const poses = gui.addFolder("Poses");
          const morphs = gui.addFolder("Morphs");

          function getBaseName(s) {
            return s.slice(s.lastIndexOf("/") + 1);
          }

          function initControls() {
            for (const key in dictionary) {
              controls[key] = 0.0;
            }

            controls.pose = -1;

            for (let i = 0; i < vpdFiles.length; i++) {
              controls[getBaseName(vpdFiles[i])] = false;
            }
          }

          function initKeys() {
            for (const key in dictionary) {
              keys.push(key);
            }
          }

          function initPoses() {
            const files = { default: -1 };

            for (let i = 0; i < vpdFiles.length; i++) {
              files[getBaseName(vpdFiles[i])] = i;
            }

            poses.add(controls, "pose", files).onChange(onChangePose);
          }

          function initMorphs() {
            for (const key in dictionary) {
              morphs.add(controls, key, 0.0, 1.0, 0.01).onChange(onChangeMorph);
            }
          }

          function onChangeMorph() {
            for (let i = 0; i < keys.length; i++) {
              const key = keys[i];
              const value = controls[key];
              mesh.morphTargetInfluences[i] = value;
            }
          }

          function onChangePose() {
            const index = parseInt(controls.pose);

            if (index === -1) {
              mesh.pose();
            } else {
              helper.pose(mesh, vpds[index]);
            }
          }

          initControls();
          initKeys();
          initPoses();
          initMorphs();

          onChangeMorph();
          onChangePose();

          poses.open();
          morphs.open();
        }
      }

      function onWindowResize() {
        let scale = 30;
        camera.left = window.innerWidth / scale / -2;
        camera.right = window.innerWidth / scale / 2;
        camera.top = window.innerHeight / scale / 2;
        camera.bottom = window.innerHeight / scale / -2;
        camera.updateProjectionMatrix();

        effect.setSize(window.innerWidth, window.innerHeight);
      }

      //滑鼠點擊
      function onMouseClick(event) {
        mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;
        raycaster.setFromCamera(mouse, camera);
        intersects = raycaster.intersectObjects(targetList);
        if (keyDOWN) {
          if (LDownLine == null) {
            Point1.push(
              new THREE.Vector3(
                intersects[0].point.x - 0.75,
                intersects[0].point.y,
                20
              )
            );
            Point1.push(
              new THREE.Vector3(
                intersects[0].point.x + 0.75,
                intersects[0].point.y,
                20
              )
            );

            RPoint1.push(
              new THREE.Vector3(
                -(intersects[0].point.x - 0.75),
                intersects[0].point.y,
                20
              )
            );
            RPoint1.push(
              new THREE.Vector3(
                -(intersects[0].point.x + 0.75),
                intersects[0].point.y,
                20
              )
            );

            const secGeometry = new THREE.BufferGeometry().setFromPoints(
              Point1
            );

            LDownLine = new THREE.Line(secGeometry, lineMaterial1);
            scene.add(LDownLine);
          } else {
            scene.remove(LDownLine);
            LDownLine = null;
            Point1.length = 0;
            RPoint1.length = 0;
          }
        }
        if (keyLEFT) {
          if (LLeftLine == null) {
            Point2.push(
              new THREE.Vector3(
                intersects[0].point.x,
                intersects[0].point.y - 0.75,
                20
              )
            );
            Point2.push(
              new THREE.Vector3(
                intersects[0].point.x,
                intersects[0].point.y + 0.75,
                20
              )
            );

            RPoint2.push(
              new THREE.Vector3(
                -intersects[0].point.x,
                intersects[0].point.y - 0.75,
                20
              )
            );
            RPoint2.push(
              new THREE.Vector3(
                -intersects[0].point.x,
                intersects[0].point.y + 0.75,
                20
              )
            );

            const secGeometry = new THREE.BufferGeometry().setFromPoints(
              Point2
            );

            LLeftLine = new THREE.Line(secGeometry, lineMaterial2);
            scene.add(LLeftLine);
          } else {
            scene.remove(LLeftLine);
            LLeftLine = null;
            Point2.length = 0;
            RPoint2.length = 0;
          }
        }
        if (keyRIGHT) {
          if (LRightLine == null) {
            Point3.push(
              new THREE.Vector3(
                intersects[0].point.x,
                intersects[0].point.y - 0.75,
                20
              )
            );
            Point3.push(
              new THREE.Vector3(
                intersects[0].point.x,
                intersects[0].point.y + 0.75,
                20
              )
            );

            RPoint3.push(
              new THREE.Vector3(
                -intersects[0].point.x,
                intersects[0].point.y - 0.75,
                20
              )
            );
            RPoint3.push(
              new THREE.Vector3(
                -intersects[0].point.x,
                intersects[0].point.y + 0.75,
                20
              )
            );

            const secGeometry = new THREE.BufferGeometry().setFromPoints(
              Point3
            );

            LRightLine = new THREE.Line(secGeometry, lineMaterial2);
            scene.add(LRightLine);
          } else {
            scene.remove(LRightLine);
            LRightLine = null;
            Point3.length = 0;
            RPoint3.length = 0;
          }
        }
        if (keyUP) {
          if (LUpLine == null) {
            Point4.push(
              new THREE.Vector3(
                intersects[0].point.x - 0.75,
                intersects[0].point.y,
                20
              )
            );
            Point4.push(
              new THREE.Vector3(
                intersects[0].point.x + 0.75,
                intersects[0].point.y,
                20
              )
            );
            RPoint4.push(
              new THREE.Vector3(
                -(intersects[0].point.x - 0.75),
                intersects[0].point.y,
                20
              )
            );
            RPoint4.push(
              new THREE.Vector3(
                -(intersects[0].point.x + 0.75),
                intersects[0].point.y,
                20
              )
            );

            const secGeometry = new THREE.BufferGeometry().setFromPoints(
              Point4
            );
            console.log("UP");
            LUpLine = new THREE.Line(secGeometry, lineMaterial1);
            scene.add(LUpLine);
          } else {
            scene.remove(LUpLine);
            LUpLine = null;
            Point4.length = 0;
            RPoint4.length = 0;
          }
        }
      }

      //鍵盤點擊
      function onKeyClick() {
        window.addEventListener("keydown", function (e) {
          if (e.code == "Digit1") {
            keyDOWN = true;
            keyLEFT = false;
            keyRIGHT = false;
            keyUP = false;
          }
          if (e.code == "Digit2") {
            keyDOWN = false;
            keyLEFT = true;
            keyRIGHT = false;
            keyUP = false;
          }
          if (e.code == "Digit3") {
            keyDOWN = false;
            keyLEFT = false;
            keyRIGHT = false;
            keyUP = true;
          }
          if (e.code == "Digit4") {
            keyDOWN = false;
            keyLEFT = false;
            keyRIGHT = true;
            keyUP = false;
          }
          if (e.code == "KeyA") {
          }
          if (e.code == "KeyQ") {
            if (
              RDLine == null &&
              RLLine == null &&
              RULine == null &&
              RRLine == null
            ) {
              const secGeometry1 = new THREE.BufferGeometry().setFromPoints(
                RPoint1
              );
              const secGeometry2 = new THREE.BufferGeometry().setFromPoints(
                RPoint2
              );
              const secGeometry3 = new THREE.BufferGeometry().setFromPoints(
                RPoint3
              );
              const secGeometry4 = new THREE.BufferGeometry().setFromPoints(
                RPoint4
              );

              RDLine = new THREE.Line(secGeometry1, lineMaterial3);
              RULine = new THREE.Line(secGeometry4, lineMaterial3);
              RLLine = new THREE.Line(secGeometry2, lineMaterial4);
              RRLine = new THREE.Line(secGeometry3, lineMaterial4);
              scene.add(RDLine);
              scene.add(RULine);
              scene.add(RLLine);
              scene.add(RRLine);
            } else {
              scene.remove(RDLine);
              scene.remove(RULine);
              scene.remove(RLLine);
              scene.remove(RRLine);
              RDLine = null;
              RLLine = null;
              RLLine = null;
              RRLine = null;
              const secGeometry1 = new THREE.BufferGeometry().setFromPoints(
                RPoint1
              );
              const secGeometry2 = new THREE.BufferGeometry().setFromPoints(
                RPoint2
              );
              const secGeometry3 = new THREE.BufferGeometry().setFromPoints(
                RPoint3
              );
              const secGeometry4 = new THREE.BufferGeometry().setFromPoints(
                RPoint4
              );

              RDLine = new THREE.Line(secGeometry1, lineMaterial3);
              RULine = new THREE.Line(secGeometry4, lineMaterial3);
              RLLine = new THREE.Line(secGeometry2, lineMaterial4);
              RRLine = new THREE.Line(secGeometry3, lineMaterial4);
              scene.add(RDLine);
              scene.add(RULine);
              scene.add(RLLine);
              scene.add(RRLine);
            }
          }
        });
      }
      window.addEventListener("click", onMouseClick, true);
      window.addEventListener("keydown", onKeyClick, true);

      function animate() {
        requestAnimationFrame(animate);
        render();
      }

      function render() {
        effect.render(scene, camera);
      }
    </script>
  </body>
</html>
